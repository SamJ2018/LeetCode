## 建议
1. 程序设计语言也是人和人的语言（多一点注释，易于理解）
2. 速度尽可能快，存储空间也要尽可能少！(alogirthm + data structures) * effcient
3. 计算（应用）alogrithms  data srtuctures

### 算法如何度量？
1. 测量很重要
2. 正确性？   （功能与问题一致，数学证明）
   成本？     （时间，空间）
3. 等价类：观察问题实例的规模，往往才是计算成本的主要因素
4. T(n) = max {T(P) |  |P| = n} 只关注最坏的情况

### 特定问题 + 不同算法
1. 实验统计法  （规模，类型）
	* 图灵机
	* RAM
	* 不依赖于cpu主频，而是cpu执行多少次计算（基本操作时间）


### 有效算法  Vs  无效算法  O(n^c) vs O(2^n)
1. 正确性(不变性 x 单调性) + 复杂度

### 复杂度分析
*	迭代：级数求和
	算数级数,幂方级数,几何级数,收敛级数
*	递归：递归跟踪 + 递推方程
*	猜测 + 验证


### 封底方法  （抓住主要问题）


## 减而知治
划分两个子问题  （平凡，规模减小）
```
	return ( n < 1 )? 0 : sum( A , n-1  ) + A[ n - 1 ];
```
	线性递归
	
	递推方程 类似解微分方程
	T(n) = T(n-1) + O(1)
	T(0) = O(1)   

## 分而治之
划分两个子问题  （规模相当） 分别求解子问题


