# 顺序统计、中值

> 给一组数，无序，要求找到第k小的数。

- 通过排序该组数，然后返回A[k]
- 除了排序的方法，有没有线性的解决办法

## 解决办法

- 若k为1，即找最小值，遍历记录最小值
- 若k为n，即找最大值，遍历记录最大值
- 若k为n/2，即找中位数

给出两种思路以线性时间代价解决该问题

### 随机的分治算法

- 类似快速排序，但只递归处理划分的一变

#### 伪代码

``` 
RAND-SELECT(A,p,r,i)
	if p==r
		return A[p]
	q = RAMD-PARTITION(A,p,r)
	k=q-p+1
	if i==k
		return A[q]
	else if i<k
		return RAND-SELECT(A,p,q-1,i)
	elss return RAND-SELECT(A,q+1,r,i-k)
```

#### 分析 

> 如果有相同的元素就会混乱

##### 不幸运划分【最坏情况

- T(n)  = T(n-1) +Θ(n)
  - 替换法，θ(n^2)

##### 幸运划分 【最好情况

- 幸运情况下，要找的数在划分的多数当中
- T(n) = T(9/10n)+Θ(n)
  - 主分析法，情况三，θ(n)

##### 期望运行时间

- 类似快速排序算法期望运行时间的证明
  - 用到指示器随机变量，非1即0
  - 期望的线性性质
  - 积的期望等于期望的积【独立性，声明选择的随机数字是相互独立的
  - 证明结果为θ(n)

## 最坏情况为线性时间的选择算法

- 需要确定一个很好的主元，递归寻找一个好的主元
- 不再是随机选择主元，先通过递归查找好的主元，可以避免随机选择的最坏情况

### 步骤

- 将输入数组的n个元素划分为n/5组，每组5个元素，且至多只有一组由剩下的n mod5组成 线性时间
- 找出每一组的中位数，对每组元素进行插入排序去确定每组的中位数    T(n)
- 对找出的中位数，找出其中的中位数x   T(n/5)
- 利用x对输入数组进行划分，让k比划分的低区中的数目多1，因此x是第k小的元素，且有n-k个元素在大的 线性时间
- 如果i=k,返回x，如果i<k，在低区递归调用找出第i小的，如果i>k，找出i-k  递归

> T(n) = T(n/5) + T(3/4n) +Θ(n)   此处3/4n为简化10进制计算为二进制
>
> 代换法证明其为T(n)<=cn

### 理解

- 画图分析

> 并不常用，常数过大

### 为什么是5组？

- 5组是最小的能使结论成立的，为什么？