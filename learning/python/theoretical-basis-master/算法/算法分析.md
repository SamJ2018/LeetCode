# 算法分析

> 算法分析是理论研究，是关于计算机程序性能和资源利用的研究。【尤其关注于性能

## 循序渐进的提问

- 在程序设计方面，什么对性能更重要？

  - 我：安全、成本、代码简洁易懂、代码逻辑清晰。

  > 正确性、简洁、可维护性、成本、稳定性、特性、功能性、模块化、安全、可扩展性、用户友好性

- 如果算法和性能并不那么重要，那么我们为什么要学习算法和性能呢?

  - 我：具备一定的性能是一些程序设计的硬件要求，比如一些访问、一些查询就是要求要1s内查出结果，然后在此之上再去考虑其正确性及其他。

  > 其一，通常性能的快速界定是否可行。算法处于解决问题的前提，将不可行变成可行
  >
  > 其二，算法是一种描述程序行为的语言，你需要性能作为支付其它东西的“货币”
  >
  > 其三，速度总是让人向往【享受其中的乐趣

## 排序问题

```
输入：n个数的一个序列<a1,a2,…>
输出：输入序列的一个排序<a1',a2',…>,满足a1'<=a2'<=……
```

### 插入算法

#### 伪代码：

```
INSERTION-SORT(A)
for j=2 to A.length   
	key = A[j]
	i = j - 1
	while i>0 and A[i] >key
		A[i+1] = A[i]
		i = i - 1
	A[i+1] = key
```

#### 运行时间

- 区别于输入的排序情况

- 区别于输入的规模

- 运行时间的上界【第一次看到把这个和承诺联系起来的说法】

  > 它代表对用户的承诺

#### 用渐进分析分析插入算法

- 内存应用计数
- 见算法导论第三版P14

### 归并排序算法：

#### 操作

- 分解待排序的n个元素各有n/2各元素  Θ(1)
- 归并排序递归排序两个子序列 2T(n/2)
- 合并两个已经排序的  Θ(n)

#### 伪代码：

```
MERGE(A,p,q,r)
n1=q-p+1
n2=r-q
for i=1 to n1
	L[i] = A[p+i-1]
for j=1 to n2
	R[j] = A[q+r]
L[n1+1] = ∞
R[n2+1] = ∞
i=1
j=1
for k=p to r
	if L[i] <=R[j]
		A[k] = L[i]
		i = i+1
	else A[k] = R[j]
		j = j+1
MERGE-SORT(A,p,r)
if p<r
	q = [(p+r)/2]
	MERGE-SORT(A,p,q)
	MERGE-SORT(A,q+1,r)
	MERGE(A,p,q,r)
```

##### 递归树

- 见P21

## 各种分析的概念

### 最坏情况分析【常用

- 程序运行的最长可能消耗时间

### 平均情况分析

- 就是所有可能输入的期望时间

> 期望时间：加权平均值。情况出现的概率*情况耗费时间求和

- 

### 最好情况分析【称为bogus

- 这可以用来骗人

### 什么是运算时间

- 取决于电脑设备
  - 相对速度
  - 绝对速度

## 算法的大局观

### 渐进分析

- 忽视机器的常量
- 关注运行时间的增长

##### 渐进符号

- Θ符号：弃去低阶项，并忽略前面的常数因子