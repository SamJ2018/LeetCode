# 哈希表【散列表

## 符号表问题

> 有一个表S，里面放着n条记录，对于每条记录，记录通常是指着数据【key】的指针，还会有一些卫星数据，卫星数据是属于key的附加数据

### 直接寻址表

> 假设应用到一个动态集合中，每个元素都是取自于全域U={0，1，…,m-1}中的一个关键字，用一个数组记作T[0,…,m-1]

- 具有关键字k的元素被存放到槽k中

#### 操作

- 添加(S,x)
  - T[x.key] = x
- 删除(S,x)
  - T[x.key] = null
- 搜索(S,k)
  - key[k]  返回，如果没有返回null

> 所有操作在最坏情况下的复杂度为Θ(1)

#### 局限性

- 若全域U过大，要存储的空间要求就很大
- 实际存储的关键字集合K相对于U可能很小，使得分配给T的大部分空间浪费了

### 散列表

> 为了保持直接寻址表的优势，且有效避免局限性，设计了散列表

- 具有关键字k的元素存放在槽h(k)中，利用散列函数h，由关键字计算得到槽的位置。

#### 冲突

> 两个关键字可能映射到同一个槽中，这种情况称为冲突

##### 链接法解决冲突问题

- 将哈希值相同的元素用链表存储

###### 分析

最坏情况：所有的哈希值都相同，全部映射到同一个槽里

- 此时就只是考虑成链表，那么查找的事件为Θ(n)

平均情况：假设情况为简单均匀散列

- 简单均匀散列即假定任何一个给定元素等可能地散列到m个槽中地任何一个，且与其它元素散列到什么位置上无关

  - T的装载因子为α=n/m

  - 记列表T[J]的长度为n_j，E[n_j] = n/m

- 在以上假设情况下，用链接法解决冲突的散列值，一次不成功查找的平均时间为θ(1+α)

  - 其中的1是把键用散列函数计算初对应的槽，α是搜索槽对应的链表
  - 成功查找的可以类似证明

- 预计搜索时间为Θ(1)的情况：结合上式，当α为O(n)时，即n=O(m),即散列表中槽数至少与表中元素数成正比

[关于散列函数的选择](#jump)

##### 开放寻址法解决冲突问题

> 所有的元素都存放到散列表里,当查找某个元素时，要系统的检查所有的表项，知道找到所需要的元素

###### 思想

- 需要插入一个元素时，系统的检查表，直到找到一个空槽，检查的顺序依赖于待插入的关键字
- 散列函数变为：U×{0，1，…，m-1}->{0,1,…,m-1}
  - 对每一个关键字k，使用开放寻址法的探查序列
    - 探查序列是一个打乱顺序的数字序列
- 哈希表内元素的数量要小于槽的数量

###### 查找方法

- 线性探查：h(k,i) = (h`(k)+i) mod m  【相当于每次查找时有个偏移量，由辅助散列函数得到
  - 容易出现一次集群现象
    - 某个区域会被占满，连续占有的槽变长，查找时要遍历这个区域内的所有
- 二次探查：h(k,i) = (h`(k)+c_1*i+c_2\*i**2) mod m 【增加一个偏移量
  - 会导致一种轻度的集群，但工作的不错，m通常取2的r次幂
- 双重探查：

###### 分析

假设：

- 均匀哈希
  - 所有键均等的有m!种探查序列，每个键都是相互独立的
- 对于一次不成功的查找，其期望的探查次数最多为1/(1-α)

### <span id="jump">散列函数</span>

- 把键均匀分布到槽里
- 键本身的特性不会影响到它在表中的分布特性

#### 除法散列法

> 通过取k除以m的余数

- h(k) = k mod m
- 不要用太小的m
  - 假设m=2，且所有的key为偶数
    - 浪费了一半的槽
  - 假设m=2**r
    - 只取决于最后的r位数字

一个不太接近2的整数幂的素数通常是个不错的选择

#### 乘法散列法

> 基本上只用到了乘法运算

##### 假设条件

- 槽的数量m=2**r，且假定计算机的字长为w位
- h(k) = (A*k mod 2**w) 右偏移(w-r) 
  - A不要太接近以2为底的数
  - 快速的方法

步骤：

- 用关键字k乘上常数A（0<A<1)，并提取k*A的小数部分
- 用m乘以这个值，再向下取整

##### 画图理解

- 类似转盘理解k*A

#### 全域散列法

> 总会有一些不好的键集容易全部散列到同一个槽中，任何一个特定的散列函数都可能出现这种最坏情况，唯一有效的改进方法是随机地选择散列函数，使之独立于要存储地关键字，这个方法就叫全域散列。

- 设H为一组有限散列函数，它将给定地关键字全域U映射到{0，1，…，m-1}中。这样地一个函数组称为全域的。
  - 可以看作，如果对每一对不同地关键字k,l属于U，满足h(k)=h(l)地散列函数的个数至多为H/m
  - 还可以看作，如果从H中随机选择一个散列函数，当关键字k!=l时，两者发生冲突的概率为1/m

##### 定理

- 如果h选自一组全域散列函数，将n个关键字散列到一个大小为m的的表T中，并用链表法解决冲突。如果关键字k不在表中，则k被散列到其中的链表的期望长度至多为装载因子n/m，如果k在表中，期望长度至多为1+n/m。

##### 如何构造全域散列函数类

- 选择一个足够大的素数p，使得每一个可能的关键字都落在0到p的范围内【将k看出一个r+1位的m进制数
- 随机的选择一个数a【m进制】，
  - h = ((ak+b) mod p)mod  m

### 完全散列

> 实现最坏情况下用O(1)次访存完成

##### 设计

- 使用一个双极结构，并且在每一级都使用全域离散，实现在第二级没有碰撞
  - 通过适当的选择第一级散列函数，可以将预期使用的总体存储空间限制在O(n)



